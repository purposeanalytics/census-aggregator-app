---
title: "CensusAggregator Report"
output:
  html_document:
    theme:
      version: 4
params:
  geo_uid: !r c("5350167.02", "5350167.01", "5350165.00", "5350164.00", "5350163.00", "5350162.00", "5350161.00", "5350131.00", "5350130.00", "5350126.00", "5350125.00", "5350124.00", "5350123.00", "5350122.00", "5350121.00", "5350120.00", "5350119.00", "5350118.00", "5350117.00", "5350116.00", "5350115.00", "5350114.00", "5350113.00", "5350112.00", "5350110.00", "5350109.00", "5350097.04", "5350097.03", "5350097.01", "5350096.02", "5350096.01", "5350095.00", "5350094.00", "5350093.00", "5350092.00", "5350091.02", "5350091.01", "5350090.00", "5350089.00", "5350088.00", "5350087.00", "5350086.00", "5350064.00", "5350063.06", "5350063.05", "5350063.04", "5350063.03", "5350062.04", "5350062.03", "5350062.01", "5350061.00", "5350060.00", "5350059.00", "5350058.00", "5350057.00", "5350056.00", "5350055.00", "5350054.00", "5350053.00", "5350047.04", "5350047.03", "5350047.02", "5350046.00", "5350045.00", "5350044.01", "5350043.00", "5350042.00", "5350041.00", "5350040.00", "5350039.00", "5350038.00", "5350037.00", "5350036.00", "5350035.00", "5350034.02", "5350034.01", "5350015.00", "5350014.00", "5350011.02", "5350011.01")
  geography: "ct"
  csv_location: "data_export.csv"
  bookmark: "https://censusaggregator.ca/"
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE,
  out.width = "100%", fig.height = 2, error = TRUE
)
```

```{css css-styles}
@import url('https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap');

:root {
  --font: "Lato", Sans-Serif;
  --base-size: 14px;
  --regular-weight: 400;
  --bold-weight: 700;
  --main-background-color: #61A89A;
  --main-color: #447E72;
  --secondary-color: #3D3D3D;
  --tertiary-color: #BFBFBF;
  --breathing-room: 10px
}

body {
  font-family: var(--font);
  font-size: var(--base-size);
  font-weight: var(--regular-weight);
}

.title {
  display: none;
}

.section-heading hr {
  border-top: 2px solid var(--main-background-color);
}

.subsection-heading {
  font-weight: var(--bold-weight);
  background-color: white;
  color: var(--main-color);
  padding-top: 0.5rem;
  padding-bottom: 0;
}

.box {
  height: 100%;
  background-color: var(--main-background-color);
  color: white;
  # text-align: center;
  padding: 0.5rem;
  # margin-right: 0.5rem;
  display: flex;
  flex-direction: column;
}

.card-value {
  margin-top: auto;
  font-size: 2rem;
  font-weight: bold;
}

h1 {
  font-size: 2rem;
}

h2 {
  font-size: 1.25rem;
}

.print-header {
  display: block;
  width: 100%;
}

.print-header.page-header {
  display: none;
}

.print-header .left-logo {
  float: left;
  text-align: left;
  width: 50%
}

.print-header .right-logo {
  float: right;
  text-align: right;
  width: 50%
}

@media print {
  .pagebreak {
    page-break-before: always;
  }

  .print-header.page-header {
    display: block;
  }

  @page {
    @bottom-center {
      content: counter(page);
    }
  }
}
```

```{r html-utils}
section_heading <- function(title) {
  htmltools::div(
    htmltools::hr(),
    htmltools::div(
      class = "section-heading",
      htmltools::h1(title),
      htmltools::hr()
    )
  )
}

subsection_heading <- function(title, class = NULL) {
  htmltools::div(
    class = "subsection-heading",
    htmltools::h2(title)
  )
}

snapshot_card_value <- function(value) {
  htmltools::div(
    class = "card-value",
    value
  )
}

snapshot_card <- function(title, value, ..., class = NULL) {
  htmltools::div(
    class = paste("box", class),
    htmltools::div(htmltools::HTML(title)),
    snapshot_card_value(value),
    htmltools::div(...)
  )
}

header_and_barchart <- function(...) {
  shiny::column(
    width = 6,
    ...
  )
}

pull_and_format_value <- function(data, format = "percent", column = "value") {
  value <- data[[column]]

  if (is.na(value)) {
    return(htmltools::HTML("&#8212;"))
  }

  switch(format,
    percent = scales::percent(value, 0.1),
    comma = scales::comma(value, 1),
    dollar = scales::dollar(value)
  )
}

logo <- function(pagebreak = TRUE) {
  logo_height <- "100px"

  shiny::div(
    class = "print-header",
    shiny::div(
      class = "left-logo",
      shiny::img(
        src = system.file("app/www/logo.png", package = "censusaggregatorapp"),
        height = logo_height,
        alt = "CensusAggregator logo"
      ), style = ""
    ),
    shiny::div(
      class = "right-logo",
      shiny::img(
        src = system.file("app/www/pa-logo.png", package = "censusaggregatorapp"),
        height = logo_height,
        alt = "Purpose Analytics logo"
      )
    )
  )
}
```

```{r packages}
library(dplyr)
library(censusaggregate)
library(purrr)
library(scales)
library(tidyr)
library(stringr)
library(bslib)
library(arrow)
library(censusaggregatorapp)
library(sfarrow)
library(ggplot2)
library(sf)
library(forcats)
```

```{r data}
geography <- params$geography
regions <- params$geo_uid

data <- prepare_data(geography, regions) %>%
  split(.$label) %>%
  purrr::map(~ .x %>%
    select(-label) %>%
    rename(label = breakdown))
```

```{r}
logo(FALSE)
```

```{r map, fig.height = 3.25, dpi = 150, fig.alt = "A map showing the outline of the selected geographies."}
boundaries_dataset <- glue::glue("extdata/{geography}")

boundaries_data <- open_dataset(system.file(boundaries_dataset, package = "censusaggregatorapp"))
boundaries_data <- boundaries_data %>%
  read_sf_dataset()

# Limit to regions, combine boundaries
region_boundaries <- boundaries_data %>%
  filter(geo_uid %in% regions)
region_boundaries <- region_boundaries %>%
  st_union()

# Get bounding box
regions_bbox <- region_boundaries %>%
  st_bbox()

# Add 10% buffer to bbox, based on which of height/width is smaller
smaller_size <- min(regions_bbox$xmax - regions_bbox$xmin, regions_bbox$ymax - regions_bbox$ymin)
bbox_buffer <- smaller_size * 0.05

regions_bbox[["xmin"]] <- regions_bbox$xmin - bbox_buffer
regions_bbox[["ymin"]] <- regions_bbox$ymin - bbox_buffer
regions_bbox[["xmax"]] <- regions_bbox$xmax + bbox_buffer
regions_bbox[["ymax"]] <- regions_bbox$ymax + bbox_buffer

# Get all boundaries within bbox
all_boundaries_in_bbox <- boundaries_data %>%
  st_crop(regions_bbox)

ggplot() +
  geom_sf(data = all_boundaries_in_bbox, colour = "grey", fill = NA, size = 0.3) +
  geom_sf(data = region_boundaries, colour = "black", fill = "white", alpha = 0.75, size = 0.5) +
  geom_rect(aes(xmin = regions_bbox$xmin, xmax = regions_bbox$xmax, ymin = regions_bbox$ymin, ymax = regions_bbox$ymax), fill = NA, colour = "grey", size = 0.3) +
  theme_void()

# tmap::tm_shape(all_boundaries_in_bbox) + tmap::tm_polygons(alpha = 0, border.col = "grey") + tmap::tm_shape(region_boundaries) + tmap::tm_polygons(alpha = 0.75, border.col = "black", col = "white") + tmap::tm_layout(frame = FALSE)
```

```{r}
shiny::tags$a(href = params$bookmark, "Bookmark", target = "_blank")
```


::: {.row .mb-2}

```{r snapshot}
population <- data[["Population, 2021"]] %>%
  pull_and_format_value("comma")

households <- data[["Households"]] %>%
  pull_and_format_value("comma")

population_change <- data[["Population change, 2016 to 2021"]] %>%
  pull_and_format_value()

if (!str_starts(population_change, "-")) {
  population_change <- paste0("+", population_change)
}

population_density <- data[["Population density"]] %>%
  pull_and_format_value("comma")
```

```{r population}
shiny::column(
  width = 3,
  snapshot_card("Population", population)
)
```

```{r households}
shiny::column(
  width = 3,
  snapshot_card("Households", households)
)
```

```{r population_change}
shiny::column(
  width = 3,
  snapshot_card("Population change<br>(2016 to 2021)", population_change)
)
```

```{r population_density}
shiny::column(
  width = 3,
  snapshot_card("Population density<br>(people/km<sup>2</sup>)", population_density)
)
```

:::

```{r section-age-households-families}
section_heading("Age, households, and families")
```

::: {.row .mb-2}

```{r age-cohorts-household-size-family-type}
header_and_barchart(
  subsection_heading("Population by age cohorts"),
  data[["Age (cohorts)"]] %>%
    inline_barchart(),
  subsection_heading("Private households by size"),
  data[["Household size"]] %>%
    inline_barchart()
)
```

```{r household_type}
header_and_barchart(
  subsection_heading("Family type"),
  data[["Family type"]] %>%
    inline_barchart(),
  subsection_heading("Household type"),
  data[["Household type"]] %>%
    inline_barchart()
)
```

:::

<div class = "pagebreak"></div>

```{r section-language}
section_heading("Language")
```

::: {.row .mb-2}

```{r knowledge_of_english}
shiny::column(
  width = 3,
  snapshot_card(
    "Knowledge of English",
    data[["Knowledge of official languages"]] %>% filter(label == "Knowledge of English") %>% pull_and_format_value(column = "value_proportion")
  )
)
```

```{r knowledge_of_french}
shiny::column(
  width = 3,
  snapshot_card("Knowledge of French", data[["Knowledge of official languages"]] %>% filter(label == "Knowledge of French") %>% pull_and_format_value(column = "value_proportion"))
)
```

```{r english-at-home}
shiny::column(
  width = 3,
  snapshot_card("English spoken at home", data[["Official languages primarily spoken at home"]] %>% filter(label == "English spoken at home") %>% pull_and_format_value(column = "value_proportion"))
)
```

```{r french-at-home}
shiny::column(
  width = 3,
  snapshot_card("French spoken at home", data[["Official languages primarily spoken at home"]] %>% filter(label == "French spoken at home") %>% pull_and_format_value(column = "value_proportion"))
)
```

:::

::: {.row}

```{r language_at_home}
header_and_barchart(
  subsection_heading("Non-official language spoken at home"),
  data[["Top 10 non-official languages primarily spoken at home"]] %>%
    inline_barchart()
)
```

:::

```{r section-income-housing}
section_heading("Income and housing")
```

::: {.row .mb-2}

```{r median_income}
# If there is only one region, just report the actual median
# Otherwise, estimate the median

if (length(regions) == 1) {
  median_income <- vectors_data %>%
    filter(vector == "v_CA21_906")
  median_income_label <- "Median household income"
} else {
  median_income <- data_breakdown %>%
    filter(label_short == "income") %>%
    aggregate_estimated_median_income()
  median_income_label <- "Estimated median household income"
}

median_income <- median_income %>%
  pull_and_format_value("dollar")

shiny::column(
  width = 4,
  snapshot_card(median_income_label, median_income)
)
```

```{r lim_at}
shiny::column(
  width = 4,
  snapshot_card("Low income (LIM-AT)", data[["Low-income measure after tax (LIM-AT)"]] %>% pull_and_format_value(column = "value_proportion"))
)
```

```{r unaffordable_housing}
shiny::column(
  width = 4,
  snapshot_card("Unaffordable housing", data[["Unaffordable housing"]] %>% pull_and_format_value(column = "value_proportion"))
)
```

:::

::: {.row}

```{r total-income}
total_income <- data_breakdown %>%
  filter(label_short == "income_buckets") %>%
  mutate(label = fct_relevel(
    label, "Under $20,000", "$20,000 to $40,000", "$40,000 to $60,000",
    "$60,000 to $80,000", "$80,000 to $100,000", "$100,000 and over"
  ))

header_and_barchart(
  subsection_heading("Total household income"),
  total_income %>%
    inline_barchart()
)
```

```{r shelter-cost}
shelter_cost <- data[["Average shelter cost"]]

# If they are all NA, then fake as proportion so that no bars are shown
shelter_cost_format <- ifelse(all(is.na(shelter_cost[["value"]])), "proportion", "dollar")

header_and_barchart(
  subsection_heading("Average shelter cost"),
  shelter_cost %>%
    inline_barchart(shelter_cost_format),
  subsection_heading("Household tenure"),
  data[["Tenure"]] %>%
    mutate(label = fct_inorder(label)) %>%
    inline_barchart()
)
```

:::

<div class = "pagebreak"></div>

```{r section-diversity-immigration}
section_heading("Diversity and immigration")
```

::: {.row .mb-2}

```{r visible-minority-summary, eval = TRUE}
visible_minority_summary <- data[["Visible minority population"]] %>%
  filter(label == "Total visible minority population") %>%
  pull_and_format_value(column = "value_proportion")

shiny::column(
  width = 3,
  snapshot_card("Visible minority", visible_minority_summary)
)
```

```{r immigrant-status, eval = TRUE}
immigrant_status_total <- data[["Immigrant status"]] %>%
  filter(label == "Immigrants") %>%
  pull_and_format_value(column = "value_proportion")

immigrant_status_recent <- data[["Immigrant status"]] %>%
  filter(label == "Recent immigrants (2016 to 2021)") %>%
  pull_and_format_value(column = "value_proportion")

shiny::column(
  width = 3,
  snapshot_card("Total immigrants", immigrant_status_total)
)

shiny::column(
  width = 3,
  snapshot_card("Recent immigrants<br>(2016 to 2021)", immigrant_status_recent)
)
```

```{r indigenous-identity}
shiny::column(
  width = 3,
  snapshot_card(
    "Indigenous identity",
    data[["Indigenous identity"]] %>%
      pull_and_format_value(column = "value_proportion")
  )
)
```

:::

::: {.row}

```{r visible-minority-breakdown}
header_and_barchart(
  subsection_heading("Visible minority population"),
  data[["Visible minority population"]] %>%
    filter(label != "Total visible minority population") %>%
    derive_census_vector_order(by_value = TRUE) %>%
    inline_barchart()
)
```

```{r ethnic_origin, eval}
header_and_barchart(
  subsection_heading("Ethnic or cultural origin"),
  ethnic_origin %>%
    inline_barchart()
)
```

:::

<div class = "pagebreak"></div>

```{r}
section_heading("Definitions")
```

::: {.row}

```{r variable-definitions}
# Split into two columns manually, after "Language spoken most often at home" will make it fit on 1 page

cutoff <- censusaggregatorapp::variable_definitions %>%
  mutate(id = row_number()) %>%
  filter(str_detect(variable_definition, "Language spoken most often at home")) %>%
  pull(id)

definitions_table <- function(data) {
  data %>%
    gt::gt() %>%
    gt::cols_align("left", variable_definition) %>%
    gt::fmt_markdown(columns = variable_definition) %>%
    gt::tab_options(
      column_labels.hidden = TRUE,
      table_body.border.bottom.color = "transparent",
      table_body.border.top.color = "transparent",
      table.font.names = "Lato",
      table.font.size = 13
    )
}

shiny::column(
  width = 6,
  censusaggregatorapp::variable_definitions %>%
    filter(row_number() <= cutoff) %>%
    definitions_table()
)

shiny::column(
  width = 6,
  censusaggregatorapp::variable_definitions %>%
    filter(row_number() > cutoff) %>%
    definitions_table()
)
```

:::

<div class = "pagebreak"></div>

```{r data-export}
# Start prepping data for export
# Add highest parent vector label to each, and relabel breakdowns to "breakdown"
highest_parent_vector_label <- data_breakdown %>%
  filter(vector == highest_parent_vector) %>%
  select(highest_parent_vector, vector = label)

breakdowns <- data_breakdown %>%
  filter(vector != highest_parent_vector) %>%
  select(highest_parent_vector, breakdown = label, value, value_proportion, label_short)

data_export <- breakdowns %>%
  left_join(highest_parent_vector_label, by = "highest_parent_vector") %>%
  select(vector, breakdown, value, value_proportion, label_short)

data_export <- bind_rows(
  tribble(
    ~vector, ~value,
    "Population, 2021", population,
    "Households", households,
    "Population change (2016 to 2021)", as.character(population_change[["value"]]),
    "Population density", population_density
  ) %>%
    mutate(
      value = readr::parse_number(value),
      value = round(value, 3),
      breakdown = vector
    ),
  # Household size
  data_export %>% filter(label_short == "household_size"),
  # (Estimated) median household income
  tibble(vector = median_income_label, value = median_income) %>%
    mutate(
      value = readr::parse_number(value),
      breakdown = vector
    ),
  # Buckets

  data_export %>%
    filter(label_short == "income_buckets") %>%
    mutate(vector = paste(vector, "($20,000 buckets)")) %>%
    mutate(breakdown = fct_relevel(breakdown, levels(total_income[["label"]]))) %>%
    arrange(breakdown),

  # Original breakdowns

  data_export %>% filter(label_short == "income"),

  # Unaffordable housing

  data_export %>% filter(label_short == "unaffordable_housing"),

  # Low-income measure after tax (LIM-AT)
  data_export %>% filter(label_short == "lim_at"),
  # Visible minority population
  # Total visible minority population (and all breakdowns within)
  data_export %>% filter(label_short == "visible_minority"),
  # Household tenure
  data_export %>% filter(label_short == "household_tenure"),
  # Average shelter cost
  data_export %>%
    filter(label_short %in% c("shelter_cost_owner", "shelter_cost_renter")) %>%
    mutate(vector = "Average monthly shelter cost") %>%
    mutate(value = round(value, 2)),
  # Age (5 year buckets)
  data_export %>%
    filter(label_short == "age") %>%
    separate(breakdown,
      into = c("min", "max"),
      sep = " to ", remove = FALSE, convert = TRUE, fill = "right"
    ) %>%
    arrange(max) %>%
    select(-min, -max) %>%
    mutate(vector = "Age (5 year groups)"),
  # Age (cohorts)
  data_export %>%
    filter(label_short == "age_cohorts") %>%
    separate(breakdown,
      into = c("min", "max"),
      sep = " to ", remove = FALSE, convert = TRUE, fill = "right"
    ) %>%
    arrange(max) %>%
    select(-min, -max) %>%
    mutate(vector = "Age (cohorts)"),
  # Language spoken at home
  # TODO - English and French
  language_at_home %>%
    rename(breakdown = label) %>%
    mutate(vector = "Top 10 non-official languages primarily spoken at home"),
  # Knowledge of English
  data_export %>% filter(label_short == "knowledge_of_english"),
  # Immigrant Status
  # Immigrants, Recent Immigrants (since 2016)
  data_export %>% filter(label_short == "immigrant_status"),
  # Indigenous identity
  data_export %>% filter(label_short == "indigenous_identity"),
  # Ethnic or cultural origin
  ethnic_origin %>%
    rename(breakdown = label) %>%
    mutate(vector = "Top 10 ethnic or cultural origins"),
  # Educational attainment
  # TODO
  # Family type
  data_export %>% filter(label_short == "family_type"),
  # Multiple family households
  data_export %>%
    filter(label_short == "household_type") %>%
    mutate(breakdown = fct_relevel(breakdown, levels(household_type[["label"]]))) %>%
    arrange(breakdown)
) %>%
  select(Vector = vector, Breakdown = breakdown, Value = value, Proportion = value_proportion) %>%
  mutate(Proportion = round(Proportion, 3))

readr::write_csv(data_export, params$csv_location, na = "")
```
